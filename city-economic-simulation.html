<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Economic City Simulation</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            overflow-x: hidden;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .city-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }
        canvas {
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .controls {
            width: 800px;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .stats {
            width: 380px;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }
        .borough-stats {
            display: flex;
            flex-wrap: wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .borough-stat {
            width: 45%;
            margin: 1%;
            padding: 5px;
            border-radius: 3px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .borough-stat:hover {
            background-color: #f0f0f0;
        }
        .buttons-container {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            background-color: #4CAF50;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        .slider-container {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .slider-container label {
            width: 200px;
        }
        input[type="range"] {
            width: 200px;
        }
        .legend {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 5px;
            border: 1px solid #ccc;
        }
        .tab-container {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        .tab {
            padding: 8px 16px;
            background-color: #ddd;
            border: none;
            cursor: pointer;
            border-radius: 4px 4px 0 0;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        .tab.active {
            background-color: #4CAF50;
            color: white;
        }
        .tooltip {
            position: fixed;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            display: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-width: 250px;
        }
        .event-item {
            background-color: #f9f9f9;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
            border-left: 4px solid #4CAF50;
        }
        .policy-options {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .policy-option {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
        }
        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }
        .policy-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        .policy-outcome {
            margin-top: 15px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 3px;
            font-style: italic;
        }
        .stats-container {
            display: flex;
            width: 800px;
            gap: 20px;
            margin-bottom: 20px;
        }
        .specialization-item {
            background-color: #f9f9f9;
            padding: 8px;
            margin: 5px 0;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Economic City Simulation</h1>
        <div class="controls">
            <div class="tab-container">
                <button class="tab active" data-view="economic">Economic Heatmap</button>
                <button class="tab" data-view="population">Population Density</button>
                <button class="tab" data-view="infrastructure">Infrastructure</button>
                <button class="tab" data-view="transport">Transport Network</button>
                <button class="tab" data-view="happiness">Happiness</button>
                <button class="tab" data-view="environment">Environment</button>
                <button class="tab" data-view="crime">Crime</button>
            </div>
            <div class="buttons-container">
                <button id="regenerate" title="Create a new random city layout">Regenerate City</button>
                <button id="run-simulation" title="Start the simulation">Run Simulation</button>
                <button id="pause-simulation" title="Pause the current simulation">Pause</button>
                <button id="trigger-event" title="Trigger a random historical event like economic boom, recession, or cultural renaissance">Trigger Event</button>
                <button id="toggle-policy" title="Open policy intervention menu to implement economic, social and infrastructure policies">Policy Menu</button>
            </div>
            <div class="slider-container">
                <label for="sim-speed" title="Controls how fast the simulation runs. Higher values = faster time passage">Simulation Speed:</label>
                <input type="range" id="sim-speed" min="1" max="20" value="5">
                <span id="speed-value" title="Current speed multiplier">5x</span>
            </div>
            <h4 style="margin-top: 10px; margin-bottom: 5px;">Heatmap View Colors:</h4>
            <div class="legend" style="display: flex; flex-wrap: wrap; justify-content: space-between; margin-bottom: 10px;">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgb(0, 0, 100)"></div>
                    <span>Declining</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgb(75, 200, 200)"></div>
                    <span>Struggling</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgb(255, 255, 0)"></div>
                    <span>Average</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgb(255, 100, 0)"></div>
                    <span>Prosperous</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgb(150, 0, 120)"></div>
                    <span>Wealthy</span>
                </div>
            </div>
            
            <div style="margin-bottom: 10px; font-size: 12px;">
                <strong>Active View:</strong> <span id="current-view-description">Economic - shows economic activity levels across the city</span>
            </div>
            
            <h4 style="margin-top: 15px; margin-bottom: 5px;">Cell Types:</h4>
            <div class="cell-legend" style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px;">
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #a6cee3; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Residential</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #1f78b4; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Commercial</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #b2df8a; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Industrial</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #33a02c; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Government</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #fb9a99; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Park</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #e31a1c; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Transport Hub</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #fdbf6f; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Road</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #cab2d6; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Water</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #ff7f00; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Tech Hub</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #6a3d9a; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Education</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #ffff99; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Healthcare</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #b15928; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Cultural</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #999999; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Slum</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #f0027f; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Luxury</span>
                </div>
                <div class="cell-type" style="display: flex; align-items: center; width: 32%; background-color: #f5f5f5; padding: 3px; border-radius: 3px;">
                    <div style="width: 15px; height: 15px; background-color: #f0f0f0; margin-right: 5px;"></div>
                    <span style="font-size: 12px;">Empty</span>
                </div>
            </div>
            
            <h4 style="margin-top: 10px; margin-bottom: 5px;">Specialized Districts:</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px;">
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üè¢</span>
                    <span style="font-size: 12px;">Economic District</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üíª</span>
                    <span style="font-size: 12px;">Tech District</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üéì</span>
                    <span style="font-size: 12px;">Education District</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üè•</span>
                    <span style="font-size: 12px;">Healthcare District</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üé≠</span>
                    <span style="font-size: 12px;">Cultural District</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üí∞</span>
                    <span style="font-size: 12px;">Financial District</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üè≠</span>
                    <span style="font-size: 12px;">Industrial Zone</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üèòÔ∏è</span>
                    <span style="font-size: 12px;">Residential Community</span>
                </div>
                <div style="display: flex; align-items: center; background-color: #f5f5f5; padding: 3px; border-radius: 3px; width: 48%;">
                    <span style="font-size: 14px; margin-right: 5px;">üíé</span>
                    <span style="font-size: 12px;">Luxury District</span>
                </div>
            </div>
            
            <h4 style="margin-top: 10px; margin-bottom: 5px;">Available Views:</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 5px; margin-bottom: 10px; font-size: 12px;">
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px; margin-right: 5px;">
                    <strong>Economic:</strong> Shows economic prosperity levels
                </div>
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px; margin-right: 5px;">
                    <strong>Population:</strong> Shows population density
                </div>
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px; margin-right: 5px;">
                    <strong>Infrastructure:</strong> Shows infrastructure quality
                </div>
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px; margin-right: 5px;">
                    <strong>Transport:</strong> Shows transport network usage
                </div>
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px; margin-right: 5px;">
                    <strong>Happiness:</strong> Shows resident wellbeing
                </div>
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px; margin-right: 5px;">
                    <strong>Environment:</strong> Shows environmental quality
                </div>
                <div style="background-color: #f5f5f5; padding: 3px 6px; border-radius: 3px;">
                    <strong>Crime:</strong> Shows safety levels (inverted)
                </div>
            </div>
            
            <h4 style="margin-top: 10px; margin-bottom: 5px;">Interface Elements:</h4>
            <div style="font-size: 12px; line-height: 1.4; background-color: #f5f5f5; padding: 10px; border-radius: 5px; margin-bottom: 10px;">
                <p><strong>Simulation Speed:</strong> The slider controls how quickly time passes in the simulation. The "5x" number shows the current speed multiplier.</p>
                
                <p><strong>Buttons:</strong></p>
                <ul style="margin: 5px 0; padding-left: 20px;">
                    <li><strong>Regenerate City:</strong> Creates a new random city layout</li>
                    <li><strong>Run Simulation:</strong> Starts or resumes the simulation</li>
                    <li><strong>Pause:</strong> Temporarily stops the simulation</li>
                    <li><strong>Trigger Event:</strong> Causes a random historical event (economic boom, recession, health crisis, etc.) to occur in the city</li>
                    <li><strong>Policy Menu:</strong> Opens a panel where you can implement various economic and social policies to shape the city's development</li>
                </ul>
                
                <p><strong>Active Events:</strong> The panel on the right shows any historical events currently affecting the city and their remaining duration.</p>
                
                <p><strong>District Specializations:</strong> Shows which boroughs have developed specialized economic functions and their strength.</p>
            </div>
        </div>
        
        <div class="city-container">
            <canvas id="cityCanvas" width="800" height="600"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>
        
        <div class="stats">
            <h3>Borough Statistics</h3>
            <p>Click on a borough for detailed statistics</p>
            <div class="borough-stats" id="borough-stats-container"></div>
            
            <div style="margin-top: 15px;">
                <h4>Simulation Stats</h4>
                <div id="simulation-stats">
                    <p>Economic Districts: <span id="district-count">0</span></p>
                    <p>Average City Economy: <span id="avg-economy">0</span></p>
                    <p>Population Density: <span id="population-density">0</span></p>
                    <p>Total City Wealth: <span id="total-wealth">0</span></p>
                    <p>Available Jobs: <span id="total-jobs">0</span></p>
                    <p>Inequality Index: <span id="inequality-index">0</span></p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 600;
        const GRID_SIZE = 10;
        const COLS = Math.floor(CANVAS_WIDTH / GRID_SIZE);
        const ROWS = Math.floor(CANVAS_HEIGHT / GRID_SIZE);
        
        // London Borough Names
        const BOROUGH_NAMES = [
            "City of London", "Westminster", "Kensington and Chelsea", "Hammersmith and Fulham",
            "Wandsworth", "Lambeth", "Southwark", "Tower Hamlets",
            "Hackney", "Islington", "Camden", "Brent",
            "Ealing", "Hounslow", "Richmond upon Thames", "Kingston upon Thames",
            "Merton", "Sutton", "Croydon", "Bromley",
            "Lewisham", "Greenwich", "Bexley", "Havering",
            "Barking and Dagenham", "Redbridge", "Newham", "Waltham Forest",
            "Haringey", "Enfield", "Barnet", "Harrow"
        ];
        
        // Cell types and colors
        const CELL_TYPES = {
            EMPTY: 0,
            RESIDENTIAL: 1,
            COMMERCIAL: 2,
            INDUSTRIAL: 3,
            GOVERNMENTAL: 4,
            PARK: 5,
            TRANSPORT: 6,
            ROAD: 7,
            WATER: 8,
            TECH_HUB: 9,       // New: Technology innovation hub
            EDUCATION: 10,      // New: Schools and universities
            HEALTHCARE: 11,     // New: Hospitals and clinics
            CULTURAL: 12,       // New: Museums, theaters, etc.
            SLUM: 13,           // New: Deteriorated housing
            LUXURY: 14          // New: High-end residential/commercial
        };
        
        // Colors for different cell types
        const CELL_COLORS = {
            [CELL_TYPES.EMPTY]: '#f0f0f0',
            [CELL_TYPES.RESIDENTIAL]: '#a6cee3',
            [CELL_TYPES.COMMERCIAL]: '#1f78b4',
            [CELL_TYPES.INDUSTRIAL]: '#b2df8a',
            [CELL_TYPES.GOVERNMENTAL]: '#33a02c',
            [CELL_TYPES.PARK]: '#fb9a99',
            [CELL_TYPES.TRANSPORT]: '#e31a1c',
            [CELL_TYPES.ROAD]: '#fdbf6f',
            [CELL_TYPES.WATER]: '#cab2d6',
            [CELL_TYPES.TECH_HUB]: '#ff7f00',     // Bright orange for tech hubs
            [CELL_TYPES.EDUCATION]: '#6a3d9a',    // Purple for education
            [CELL_TYPES.HEALTHCARE]: '#ffff99',   // Light yellow for healthcare
            [CELL_TYPES.CULTURAL]: '#b15928',     // Brown for cultural
            [CELL_TYPES.SLUM]: '#999999',         // Gray for slums
            [CELL_TYPES.LUXURY]: '#f0027f'        // Pink for luxury
        };
        
        // Global variables
        let city = [];
        let boroughs = [];
        let people = [];
        let simulationInterval;
        let simulationSpeed = 5;
        let currentView = 'economic';
        let time = 0;
        let dayTime = 8; // 8 AM start
        
        // Finite resources for the city
        const CITY_RESOURCES = {
            totalWealth: 1000000, // Total city wealth pool
            infrastructure: 100000, // Infrastructure budget
            jobs: 3000, // Limited job positions
            talents: 1000, // Expert/talented workforce
            investmentCapital: 50000, // Available investment money
            happiness: 100, // Collective well-being
            environment: 100, // Environmental quality
            security: 100 // Public safety
        };
        
        // Historical events that can occur
        const EVENTS = [
            { 
                name: "Economic Boom", 
                description: "A surge in the economy brings prosperity to certain sectors.",
                probability: 0.001, // Per step probability
                duration: 20, // How many simulation steps it lasts
                effects: {
                    wealthMultiplier: 1.2,
                    jobsMultiplier: 1.15,
                    targetTypes: [CELL_TYPES.COMMERCIAL, CELL_TYPES.TECH_HUB]
                },
                active: false,
                timeRemaining: 0
            },
            { 
                name: "Recession", 
                description: "Economic downturn affects the entire city.",
                probability: 0.001,
                duration: 30,
                effects: {
                    wealthMultiplier: 0.8,
                    jobsMultiplier: 0.85,
                    targetTypes: [CELL_TYPES.COMMERCIAL, CELL_TYPES.INDUSTRIAL]
                },
                active: false,
                timeRemaining: 0
            },
            { 
                name: "Tech Breakthrough", 
                description: "A major technological innovation emerges.",
                probability: 0.0008,
                duration: 25,
                effects: {
                    wealthMultiplier: 1.3,
                    jobsMultiplier: 1.2,
                    targetTypes: [CELL_TYPES.TECH_HUB, CELL_TYPES.EDUCATION]
                },
                active: false,
                timeRemaining: 0
            },
            { 
                name: "Cultural Renaissance", 
                description: "A cultural movement brings attention to the arts.",
                probability: 0.0008,
                duration: 20,
                effects: {
                    wealthMultiplier: 1.15,
                    happinessBonus: 10,
                    targetTypes: [CELL_TYPES.CULTURAL, CELL_TYPES.COMMERCIAL]
                },
                active: false,
                timeRemaining: 0
            },
            { 
                name: "Housing Crisis", 
                description: "Housing costs spiral out of control.",
                probability: 0.0008,
                duration: 35,
                effects: {
                    wealthMultiplier: 0.9,
                    gentrificationMultiplier: 1.5,
                    targetTypes: [CELL_TYPES.RESIDENTIAL, CELL_TYPES.LUXURY]
                },
                active: false,
                timeRemaining: 0
            },
            { 
                name: "Public Health Emergency", 
                description: "A health crisis affects the population.",
                probability: 0.0005,
                duration: 40,
                effects: {
                    populationMultiplier: 0.95,
                    economicMultiplier: 0.9,
                    targetTypes: [CELL_TYPES.RESIDENTIAL, CELL_TYPES.COMMERCIAL]
                },
                active: false,
                timeRemaining: 0
            },
            { 
                name: "Environmental Movement", 
                description: "A push for greener spaces and policies.",
                probability: 0.001,
                duration: 30,
                effects: {
                    environmentBonus: 15,
                    parkConversionChance: 0.1,
                    targetTypes: [CELL_TYPES.PARK, CELL_TYPES.INDUSTRIAL]
                },
                active: false,
                timeRemaining: 0
            }
        ];
        
        // Current active events
        let activeEvents = [];
        
        // DOM elements
        const canvas = document.getElementById('cityCanvas');
        const ctx = canvas.getContext('2d');
        const regenerateBtn = document.getElementById('regenerate');
        const runSimBtn = document.getElementById('run-simulation');
        const pauseSimBtn = document.getElementById('pause-simulation');
        const speedSlider = document.getElementById('sim-speed');
        const speedValue = document.getElementById('speed-value');
        const boroughStatsContainer = document.getElementById('borough-stats-container');
        const tooltip = document.getElementById('tooltip');
        
        // Initialize the simulation
        function init() {
            city = createEmptyGrid();
            boroughs = generateBoroughs();
            generateInfrastructure();
            people = generatePeople(2000);
            
            // Initialize borough resource allocation
            for (let i = 0; i < boroughs.length; i++) {
                // Initial resource allocation based on borough size and random factors
                const cellRatio = boroughs[i].cells.length / (ROWS * COLS);
                const randomFactor = 0.5 + Math.random();
                
                boroughs[i].wealthShare = CITY_RESOURCES.totalWealth * cellRatio * randomFactor;
                boroughs[i].jobsAllocated = Math.floor(CITY_RESOURCES.jobs * cellRatio * randomFactor);
                boroughs[i].talentsAllocated = Math.floor(CITY_RESOURCES.talents * cellRatio * randomFactor);
                boroughs[i].investmentAllocated = CITY_RESOURCES.investmentCapital * cellRatio * randomFactor;
                boroughs[i].opportunity = 50 * randomFactor;
                boroughs[i].gentrification = 0.1 * randomFactor;
                boroughs[i].status = "Stable";
                boroughs[i].happiness = 50;
                boroughs[i].environment = 50;
                boroughs[i].crimeRate = 20;
            }
            
            // Ensure total resource allocation remains consistent
            normalizeResourceAllocation();
            
            renderCity();
            updateBoroughStats();
            updateSimulationStats();
            updateEventsDisplay();
            
            // Set initial state for policy panel
            const policyPanel = document.getElementById('policy-panel');
            if (policyPanel) {
                policyPanel.style.display = 'none';
            }
            
            // Display instructions
            alert('Welcome to the Enhanced Economic City Simulation!\n\n' + 
                  'This simulation features a complex urban economy with emergent districts and social dynamics.\n\n' +
                  'Key features:\n' +
                  '- Boroughs compete for wealth, jobs, talent, and investment\n' +
                  '- Districts develop specialized functions (tech, cultural, financial, etc.)\n' +
                  '- Random events like booms, recessions, and cultural movements\n' +
                  '- Policy interventions to shape urban development\n' +
                  '- Environmental, crime, and happiness dynamics\n\n' +
                  'Click "Run Simulation" to watch the city evolve over time!');
        }
        
        // Normalize resource allocation to ensure totals match city resources
        function normalizeResourceAllocation() {
            // Calculate total current allocations
            let totalWealth = 0;
            let totalJobs = 0;
            let totalTalents = 0;
            let totalInvestment = 0;
            
            for (const borough of boroughs) {
                totalWealth += borough.wealthShare;
                totalJobs += borough.jobsAllocated;
                totalTalents += borough.talentsAllocated;
                totalInvestment += borough.investmentAllocated;
            }
            
            // Normalize to match city resources
            const wealthRatio = CITY_RESOURCES.totalWealth / totalWealth;
            const jobsRatio = CITY_RESOURCES.jobs / totalJobs;
            const talentsRatio = CITY_RESOURCES.talents / totalTalents;
            const investmentRatio = CITY_RESOURCES.investmentCapital / totalInvestment;
            
            for (const borough of boroughs) {
                borough.wealthShare *= wealthRatio;
                borough.jobsAllocated = Math.floor(borough.jobsAllocated * jobsRatio);
                borough.talentsAllocated = Math.floor(borough.talentsAllocated * talentsRatio);
                borough.investmentAllocated *= investmentRatio;
            }
        }
        
        // Create an empty grid
        function createEmptyGrid() {
            const grid = [];
            for (let y = 0; y < ROWS; y++) {
                const row = [];
                for (let x = 0; x < COLS; x++) {
                    row.push({
                        type: CELL_TYPES.EMPTY,
                        borough: null,
                        economicValue: 0,
                        population: 0,
                        infrastructure: 0,
                        transport: 0
                    });
                }
                grid.push(row);
            }
            return grid;
        }
        
        // Generate boroughs using Voronoi-like approach
        function generateBoroughs() {
            const boroughList = [];
            
            // Create borough centers
            for (let i = 0; i < BOROUGH_NAMES.length; i++) {
                boroughList.push({
                    id: i,
                    name: BOROUGH_NAMES[i],
                    center: {
                        x: Math.floor(Math.random() * COLS),
                        y: Math.floor(Math.random() * ROWS)
                    },
                    color: getRandomColor(),
                    cells: [],
                    economicValue: Math.random() * 100,
                    population: 0,
                    infrastructure: Math.random() * 100,
                    transport: Math.random() * 100,
                    wealth: 50 + Math.random() * 50,
                    employmentRate: 0.7 + Math.random() * 0.3,
                    businessCount: Math.floor(Math.random() * 100),
                    transportConnections: []
                });
            }
            
            // Assign each cell to the closest borough
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    let closestBorough = null;
                    let minDistance = Number.MAX_VALUE;
                    
                    for (let i = 0; i < boroughList.length; i++) {
                        const borough = boroughList[i];
                        const distance = Math.sqrt(
                            Math.pow(x - borough.center.x, 2) + 
                            Math.pow(y - borough.center.y, 2)
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestBorough = borough;
                        }
                    }
                    
                    city[y][x].borough = closestBorough.id;
                    boroughList[closestBorough.id].cells.push({x, y});
                }
            }
            
            // Create transport connections between boroughs
            for (let i = 0; i < boroughList.length; i++) {
                const connectionsCount = 2 + Math.floor(Math.random() * 3); // 2-4 connections
                const possibleConnections = [...Array(boroughList.length).keys()].filter(id => id !== i);
                
                for (let j = 0; j < connectionsCount; j++) {
                    if (possibleConnections.length === 0) break;
                    
                    const randomIndex = Math.floor(Math.random() * possibleConnections.length);
                    const targetId = possibleConnections[randomIndex];
                    
                    boroughList[i].transportConnections.push({
                        targetId,
                        quality: Math.random()
                    });
                    
                    possibleConnections.splice(randomIndex, 1);
                }
            }
            
            return boroughList;
        }
        
        // Generate infrastructure (buildings, roads, parks, etc.)
        function generateInfrastructure() {
            // Add water bodies
            addWaterBodies();
            
            // Add roads connecting borough centers
            addRoadNetwork();
            
            // Add different types of buildings
            for (let i = 0; i < boroughs.length; i++) {
                const borough = boroughs[i];
                
                // Determine borough character (residential, commercial, or mixed)
                const boroughCharacter = Math.random();
                let residentialRatio, commercialRatio, industrialRatio, parkRatio;
                
                if (boroughCharacter < 0.3) {
                    // Primarily residential
                    residentialRatio = 0.6;
                    commercialRatio = 0.2;
                    industrialRatio = 0.1;
                    parkRatio = 0.1;
                } else if (boroughCharacter < 0.6) {
                    // Primarily commercial
                    residentialRatio = 0.3;
                    commercialRatio = 0.5;
                    industrialRatio = 0.15;
                    parkRatio = 0.05;
                } else if (boroughCharacter < 0.8) {
                    // Primarily industrial
                    residentialRatio = 0.2;
                    commercialRatio = 0.2;
                    industrialRatio = 0.55;
                    parkRatio = 0.05;
                } else {
                    // Mixed use
                    residentialRatio = 0.4;
                    commercialRatio = 0.3;
                    industrialRatio = 0.2;
                    parkRatio = 0.1;
                }
                
                // Assign cell types based on ratios
                for (const cell of borough.cells) {
                    if (city[cell.y][cell.x].type !== CELL_TYPES.EMPTY) continue;
                    
                    const r = Math.random();
                    if (r < residentialRatio) {
                        city[cell.y][cell.x].type = CELL_TYPES.RESIDENTIAL;
                        city[cell.y][cell.x].economicValue = 10 + Math.random() * 20;
                        city[cell.y][cell.x].population = 1 + Math.random() * 4;
                    } else if (r < residentialRatio + commercialRatio) {
                        city[cell.y][cell.x].type = CELL_TYPES.COMMERCIAL;
                        city[cell.y][cell.x].economicValue = 30 + Math.random() * 40;
                        city[cell.y][cell.x].population = Math.random() * 2;
                    } else if (r < residentialRatio + commercialRatio + industrialRatio) {
                        city[cell.y][cell.x].type = CELL_TYPES.INDUSTRIAL;
                        city[cell.y][cell.x].economicValue = 50 + Math.random() * 30;
                        city[cell.y][cell.x].population = Math.random();
                    } else if (r < residentialRatio + commercialRatio + industrialRatio + parkRatio) {
                        city[cell.y][cell.x].type = CELL_TYPES.PARK;
                        city[cell.y][cell.x].economicValue = 5 + Math.random() * 10;
                        city[cell.y][cell.x].population = Math.random() * 0.5;
                    }
                    
                    // Add infrastructure value
                    city[cell.y][cell.x].infrastructure = 10 + Math.random() * 90;
                }
                
                // Add a governmental building in each borough
                const centerCell = borough.cells[Math.floor(Math.random() * borough.cells.length)];
                city[centerCell.y][centerCell.x].type = CELL_TYPES.GOVERNMENTAL;
                city[centerCell.y][centerCell.x].economicValue = 70 + Math.random() * 30;
                city[centerCell.y][centerCell.x].population = 2 + Math.random() * 3;
                
                // Add transport hubs
                const transportHubsCount = 1 + Math.floor(Math.random() * 2);
                for (let j = 0; j < transportHubsCount; j++) {
                    const hubCell = borough.cells[Math.floor(Math.random() * borough.cells.length)];
                    city[hubCell.y][hubCell.x].type = CELL_TYPES.TRANSPORT;
                    city[hubCell.y][hubCell.x].economicValue = 60 + Math.random() * 40;
                    city[hubCell.y][hubCell.x].transport = 80 + Math.random() * 20;
                    city[hubCell.y][hubCell.x].population = 1 + Math.random() * 2;
                }
            }
            
            // Calculate total population for each borough
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const boroughId = city[y][x].borough;
                    boroughs[boroughId].population += city[y][x].population;
                }
            }
        }
        
        // Add water bodies to the city
        function addWaterBodies() {
            // Add a river
            const riverStartX = Math.floor(Math.random() * COLS);
            let x = riverStartX;
            let riverWidth = 2 + Math.floor(Math.random() * 3);
            
            for (let y = 0; y < ROWS; y++) {
                // Adjust river path randomly
                if (Math.random() < 0.3) {
                    x += Math.random() < 0.5 ? -1 : 1;
                }
                
                // Keep river in bounds
                x = Math.max(0, Math.min(COLS - 1, x));
                
                // Create river width
                for (let w = -Math.floor(riverWidth/2); w <= Math.floor(riverWidth/2); w++) {
                    const riverX = x + w;
                    if (riverX >= 0 && riverX < COLS) {
                        city[y][riverX].type = CELL_TYPES.WATER;
                    }
                }
                
                // Adjust river width occasionally
                if (Math.random() < 0.1) {
                    riverWidth += Math.random() < 0.5 ? -1 : 1;
                    riverWidth = Math.max(1, Math.min(5, riverWidth));
                }
            }
            
            // Add a few lakes
            const lakesCount = 1 + Math.floor(Math.random() * 3);
            for (let i = 0; i < lakesCount; i++) {
                const centerX = Math.floor(Math.random() * COLS);
                const centerY = Math.floor(Math.random() * ROWS);
                const radius = 3 + Math.floor(Math.random() * 5);
                
                for (let y = centerY - radius; y <= centerY + radius; y++) {
                    for (let x = centerX - radius; x <= centerX + radius; x++) {
                        if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                            const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                            if (distance <= radius) {
                                city[y][x].type = CELL_TYPES.WATER;
                            }
                        }
                    }
                }
            }
        }
        
        // Add road network connecting borough centers
        function addRoadNetwork() {
            // Connect all borough centers with roads
            for (let i = 0; i < boroughs.length; i++) {
                const connections = boroughs[i].transportConnections;
                
                for (const connection of connections) {
                    const source = boroughs[i].center;
                    const target = boroughs[connection.targetId].center;
                    
                    // Draw a simple road between centers
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const steps = Math.max(Math.abs(dx), Math.abs(dy));
                    
                    for (let step = 0; step <= steps; step++) {
                        const x = Math.round(source.x + (dx * step / steps));
                        const y = Math.round(source.y + (dy * step / steps));
                        
                        if (x >= 0 && x < COLS && y >= 0 && y < ROWS && city[y][x].type === CELL_TYPES.EMPTY) {
                            city[y][x].type = CELL_TYPES.ROAD;
                            city[y][x].transport = 50 + (connection.quality * 50);
                        }
                    }
                }
            }
        }
        
        // Generate people
        function generatePeople(count) {
            const peopleList = [];
            
            for (let i = 0; i < count; i++) {
                // Assign home to a random residential cell
                let homeBorough, homeX, homeY;
                let attempts = 0;
                const maxAttempts = 50;
                
                do {
                    homeBorough = Math.floor(Math.random() * boroughs.length);
                    if (!boroughs[homeBorough] || !boroughs[homeBorough].cells || boroughs[homeBorough].cells.length === 0) {
                        continue;
                    }
                    
                    const cell = boroughs[homeBorough].cells[Math.floor(Math.random() * boroughs[homeBorough].cells.length)];
                    if (!cell) continue;
                    
                    homeX = cell.x;
                    homeY = cell.y;
                    attempts++;
                    
                    // Break the loop if too many attempts to avoid infinite loop
                    if (attempts > maxAttempts) {
                        homeX = Math.floor(Math.random() * COLS);
                        homeY = Math.floor(Math.random() * ROWS);
                        break;
                    }
                } while (!city[homeY] || !city[homeY][homeX] || city[homeY][homeX].type !== CELL_TYPES.RESIDENTIAL);
                
                // Assign work to a random commercial or industrial cell
                let workBorough, workX, workY;
                attempts = 0;
                
                do {
                    workBorough = Math.floor(Math.random() * boroughs.length);
                    if (!boroughs[workBorough] || !boroughs[workBorough].cells || boroughs[workBorough].cells.length === 0) {
                        continue;
                    }
                    
                    const cell = boroughs[workBorough].cells[Math.floor(Math.random() * boroughs[workBorough].cells.length)];
                    if (!cell) continue;
                    
                    workX = cell.x;
                    workY = cell.y;
                    attempts++;
                    
                    // Break the loop if too many attempts to avoid infinite loop
                    if (attempts > maxAttempts) {
                        workX = Math.floor(Math.random() * COLS);
                        workY = Math.floor(Math.random() * ROWS);
                        break;
                    }
                } while (!city[workY] || !city[workY][workX] || 
                         (city[workY][workX].type !== CELL_TYPES.COMMERCIAL && 
                          city[workY][workX].type !== CELL_TYPES.INDUSTRIAL && 
                          city[workY][workX].type !== CELL_TYPES.GOVERNMENTAL));
                
                // Create person with unique characteristics
                peopleList.push({
                    id: i,
                    home: { borough: homeBorough, x: homeX, y: homeY },
                    work: { borough: workBorough, x: workX, y: workY },
                    currentLocation: { x: homeX, y: homeY },
                    wealth: 50 + Math.random() * 50,
                    spendingHabit: 0.1 + Math.random() * 0.3, // 10-40% of wealth spent daily
                    skillLevel: Math.random(),
                    isWorking: true
                });
            }
            
            return peopleList;
        }
        
        // Render the city based on the current view
        function renderCity() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw base map
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = city[y][x];
                    const boroughId = cell.borough;
                    
                    // Draw borough color with transparency
                    ctx.fillStyle = hexToRgba(boroughs[boroughId].color, 0.2);
                    ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    
                    // Draw cell type
                    if (cell.type !== CELL_TYPES.EMPTY) {
                        ctx.fillStyle = CELL_COLORS[cell.type];
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            
            // Identify economic districts (clusters of commercial cells)
            const economicDistricts = findEconomicDistricts();
            
            // Draw economic district outlines
            ctx.lineWidth = 2;
            for (const district of economicDistricts) {
                ctx.strokeStyle = `hsl(${district.hue}, 100%, 50%)`;
                
                // Draw district boundary
                if (district.cells.length > 5) {
                    for (const cell of district.cells) {
                        const x = cell.x * GRID_SIZE;
                        const y = cell.y * GRID_SIZE;
                        
                        // Check if cell is on the boundary of the district
                        const neighbors = getNeighbors(cell.x, cell.y);
                        let isBoundary = false;
                        
                        for (const n of neighbors) {
                            if (n.x < 0 || n.x >= COLS || n.y < 0 || n.y >= ROWS) {
                                isBoundary = true;
                                break;
                            }
                            
                            const neighborCell = city[n.y][n.x];
                            if (neighborCell.type !== CELL_TYPES.COMMERCIAL && 
                                neighborCell.type !== CELL_TYPES.INDUSTRIAL) {
                                isBoundary = true;
                                break;
                            }
                        }
                        
                        if (isBoundary) {
                            ctx.beginPath();
                            ctx.rect(x, y, GRID_SIZE, GRID_SIZE);
                            ctx.stroke();
                        }
                    }
                    
                    // Label the district
                    const centerCell = district.cells[Math.floor(district.cells.length / 2)];
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = `hsl(${district.hue}, 100%, 30%)`;
                    ctx.textAlign = 'center';
                    ctx.fillText('üè¢', centerCell.x * GRID_SIZE + GRID_SIZE/2, centerCell.y * GRID_SIZE + GRID_SIZE/2);
                }
            }
            
            // Draw heatmap overlay based on current view
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = city[y][x];
                    let value = 0;
                    
                    switch (currentView) {
                        case 'economic':
                            value = cell.economicValue;
                            break;
                        case 'population':
                            value = cell.population * 25; // Scale to 0-100
                            break;
                        case 'infrastructure':
                            value = cell.infrastructure;
                            break;
                        case 'transport':
                            value = cell.transport;
                            break;
                        case 'happiness':
                            value = boroughs[cell.borough].happiness || 50;
                            break;
                        case 'environment':
                            value = cell.environment || 50;
                            break;
                        case 'crime':
                            value = cell.crime || 0;
                            // Reverse crime scale (higher = worse)
                            value = 100 - value;
                            break;
                    }
                    
                    if (value > 0) {
                        const alpha = Math.min(value / 100, 0.7); // Cap at 70% opacity
                        const color = getHeatmapColor(value);
                        ctx.fillStyle = hexToRgba(color, alpha);
                        ctx.fillRect(x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                    }
                }
            }
            
            // Draw people as small dots
            ctx.fillStyle = '#000';
            for (const person of people) {
                if (!person || !person.currentLocation) continue;
                
                const x = Math.max(0, Math.min(COLS - 1, person.currentLocation.x));
                const y = Math.max(0, Math.min(ROWS - 1, person.currentLocation.y));
                
                ctx.beginPath();
                ctx.arc(
                    x * GRID_SIZE + GRID_SIZE/2, 
                    y * GRID_SIZE + GRID_SIZE/2, 
                    1, 0, Math.PI * 2
                );
                ctx.fill();
            }
            
            // Draw borough borders
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5;
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const currentBorough = city[y][x].borough;
                    
                    // Check right neighbor
                    if (x < COLS - 1 && city[y][x+1].borough !== currentBorough) {
                        ctx.beginPath();
                        ctx.moveTo((x+1) * GRID_SIZE, y * GRID_SIZE);
                        ctx.lineTo((x+1) * GRID_SIZE, (y+1) * GRID_SIZE);
                        ctx.stroke();
                    }
                    
                    // Check bottom neighbor
                    if (y < ROWS - 1 && city[y+1][x].borough !== currentBorough) {
                        ctx.beginPath();
                        ctx.moveTo(x * GRID_SIZE, (y+1) * GRID_SIZE);
                        ctx.lineTo((x+1) * GRID_SIZE, (y+1) * GRID_SIZE);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw borough names
            ctx.font = '10px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'center';
            
            for (const borough of boroughs) {
                const { x, y } = borough.center;
                ctx.fillText(borough.name, x * GRID_SIZE, y * GRID_SIZE);
            }
            
            // Draw time of day
            ctx.font = '14px Arial';
            ctx.fillStyle = '#000';
            ctx.textAlign = 'left';
            ctx.fillText(`Day ${Math.floor(time / 24) + 1}, ${Math.floor(dayTime)}:00`, 10, 20);
            
            // Indicate active events
            if (activeEvents.length > 0) {
                ctx.fillStyle = '#e31a1c';
                ctx.fillText(`Active Events: ${activeEvents.length}`, 200, 20);
            }
            
            // Mark specialized districts
            for (const borough of boroughs) {
                if (borough.specialization && borough.specializationStrength > 0.4) {
                    const { x, y } = borough.center;
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#000';
                    ctx.textAlign = 'center';
                    
                    let icon = 'üè¢'; // Default
                    
                    switch (borough.specialization) {
                        case 'Technology Hub':
                            icon = 'üíª';
                            break;
                        case 'Cultural District':
                            icon = 'üé≠';
                            break;
                        case 'Financial District':
                            icon = 'üí∞';
                            break;
                        case 'Industrial Zone':
                            icon = 'üè≠';
                            break;
                        case 'Residential Community':
                            icon = 'üèòÔ∏è';
                            break;
                        case 'Luxury District':
                            icon = 'üíé';
                            break;
                        case 'Healthcare Hub':
                            icon = 'üè•';
                            break;
                        case 'Educational Center':
                            icon = 'üéì';
                            break;
                    }
                    
                    ctx.fillText(icon, x * GRID_SIZE, (y + 1) * GRID_SIZE);
                }
            }
        }
        
        // Find economic districts (clusters of commercial/industrial cells)
        function findEconomicDistricts() {
            const districts = [];
            const visited = Array(ROWS).fill().map(() => Array(COLS).fill(false));
            let districtId = 0;
            
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (visited[y][x]) continue;
                    
                    const cell = city[y][x];
                    if (!cell || (cell.type !== CELL_TYPES.COMMERCIAL && cell.type !== CELL_TYPES.INDUSTRIAL)) {
                        visited[y][x] = true;
                        continue;
                    }
                    
                    // Found a new district
                    const district = {
                        id: districtId++,
                        cells: [],
                        avgEconomicValue: 0,
                        boroughId: cell.borough,
                        hue: Math.floor(Math.random() * 360) // Random color
                    };
                    
                    // Flood fill to find all connected cells in the district
                    const floodFill = (fx, fy) => {
                        if (fx < 0 || fx >= COLS || fy < 0 || fy >= ROWS) return;
                        if (visited[fy][fx]) return;
                        
                        const fcell = city[fy][fx];
                        if (!fcell || (fcell.type !== CELL_TYPES.COMMERCIAL && fcell.type !== CELL_TYPES.INDUSTRIAL)) {
                            visited[fy][fx] = true;
                            return;
                        }
                        
                        // Add to district
                        visited[fy][fx] = true;
                        district.cells.push({x: fx, y: fy});
                        district.avgEconomicValue += fcell.economicValue;
                        
                        // Check neighbors
                        floodFill(fx+1, fy);
                        floodFill(fx-1, fy);
                        floodFill(fx, fy+1);
                        floodFill(fx, fy-1);
                    };
                    
                    floodFill(x, y);
                    
                    // Calculate average economic value
                    if (district.cells.length > 0) {
                        district.avgEconomicValue /= district.cells.length;
                        districts.push(district);
                    }
                }
            }
            
            return districts;
        }
        
        // Get heatmap color based on value (0-100) - expanded color palette
        function getHeatmapColor(value) {
            // Create a more varied color spectrum to show economic disparity
            if (value < 20) {
                // Deep blue for very poor areas (economic depression)
                const ratio = value / 20;
                const r = Math.floor(0 + (75 * ratio));
                const g = Math.floor(0 + (75 * ratio));
                const b = Math.floor(100 + (155 * ratio));
                return rgbToHex(r, g, b);
            } else if (value < 40) {
                // Purple-blue to teal transition (struggling areas)
                const ratio = (value - 20) / 20;
                const r = Math.floor(75 + (0 * ratio));
                const g = Math.floor(75 + (125 * ratio));
                const b = Math.floor(255 - (55 * ratio));
                return rgbToHex(r, g, b);
            } else if (value < 60) {
                // Teal to yellow-green transition (average areas)
                const ratio = (value - 40) / 20;
                const r = Math.floor(75 + (180 * ratio));
                const g = Math.floor(200 * (1 - ratio) + 255 * ratio);
                const b = Math.floor(200 * (1 - ratio));
                return rgbToHex(r, g, b);
            } else if (value < 80) {
                // Yellow to orange transition (prosperous areas)
                const ratio = (value - 60) / 20;
                const r = 255;
                const g = Math.floor(255 - (155 * ratio));
                const b = Math.floor(0 + (0 * ratio));
                return rgbToHex(r, g, b);
            } else {
                // Orange to purple transition (very wealthy areas)
                const ratio = (value - 80) / 20;
                const r = Math.floor(255 - (105 * ratio));
                const g = Math.floor(100 - (100 * ratio));
                const b = Math.floor(0 + (120 * ratio));
                return rgbToHex(r, g, b);
            }
        }
        
        // Run the simulation for one step
        function runSimulationStep() {
            time += 1 / simulationSpeed;
            dayTime = (dayTime + (1 / simulationSpeed)) % 24;
            
            // Check for random events
            checkForRandomEvents();
            
            // Process active events
            processActiveEvents();
            
            // Move people based on time of day
            const hour = dayTime;
            
            // Morning commute (7-9 AM)
            if (hour >= 7 && hour < 9) {
                movePeopleToWork(0.4);
            } 
            // At work (9 AM - 5 PM)
            else if (hour >= 9 && hour < 17) {
                movePeopleToWork(0.1);
                simulateWorkActivities();
            } 
            // Evening commute (5-7 PM)
            else if (hour >= 17 && hour < 19) {
                movePeopleToHome(0.4);
            } 
            // At home / evening activities (7 PM - 7 AM)
            else {
                movePeopleToHome(0.1);
                simulateHomeActivities();
            }
            
            // Calculate economic effects and update borough stats
            calculateEconomicEffects();
            simulateCrimeAndSafety();
            simulateEnvironmentalEffects();
            simulateHappinessWellbeing();
            updateBoroughStats();
            
            // Update simulation stats
            updateSimulationStats();
            
            // Occasionally reassign work locations based on economic districts
            if (Math.random() < 0.01) {  // 1% chance each step
                reassignWorkLocations();
            }
            
            // Check for industry and specialization emergent patterns
            if (Math.random() < 0.02) {  // 2% chance each step
                developSpecializations();
            }
            
            // Render the updated city
            renderCity();
            
            // Update events display
            updateEventsDisplay();
        }
        
        // Check if any random events should occur
        function checkForRandomEvents() {
            for (const event of EVENTS) {
                if (event.active) continue; // Skip already active events
                
                if (Math.random() < event.probability) {
                    // Trigger this event
                    event.active = true;
                    event.timeRemaining = event.duration;
                    activeEvents.push(event);
                    
                    // Show notification
                    alert(`Event: ${event.name}\n${event.description}`);
                }
            }
        }
        
        // Process effects from active events
        function processActiveEvents() {
            for (let i = activeEvents.length - 1; i >= 0; i--) {
                const event = activeEvents[i];
                
                // Apply event effects to relevant areas
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const cell = city[y][x];
                        
                        // Check if this cell type is affected by the event
                        if (event.effects.targetTypes.includes(cell.type)) {
                            // Apply economic effects
                            if (event.effects.wealthMultiplier) {
                                cell.economicValue *= event.effects.wealthMultiplier;
                                cell.economicValue = Math.min(100, cell.economicValue);
                            }
                            
                            // Apply population effects
                            if (event.effects.populationMultiplier && cell.population > 0) {
                                cell.population *= event.effects.populationMultiplier;
                            }
                            
                            // Apply park conversion chance
                            if (event.effects.parkConversionChance && 
                                cell.type === CELL_TYPES.EMPTY && 
                                Math.random() < event.effects.parkConversionChance) {
                                cell.type = CELL_TYPES.PARK;
                            }
                            
                            // Apply other effects to boroughs
                            const borough = boroughs[cell.borough];
                            
                            if (event.effects.jobsMultiplier) {
                                borough.jobsAllocated *= event.effects.jobsMultiplier;
                            }
                            
                            if (event.effects.happinessBonus) {
                                borough.happiness = Math.min(100, (borough.happiness || 50) + event.effects.happinessBonus / event.duration);
                            }
                            
                            if (event.effects.environmentBonus) {
                                borough.environment = Math.min(100, (borough.environment || 50) + event.effects.environmentBonus / event.duration);
                            }
                            
                            if (event.effects.gentrificationMultiplier) {
                                borough.gentrification *= event.effects.gentrificationMultiplier;
                            }
                            
                            if (event.effects.economicMultiplier) {
                                borough.economicValue *= event.effects.economicMultiplier;
                                borough.economicValue = Math.min(100, borough.economicValue);
                            }
                        }
                    }
                }
                
                // Decrease remaining time
                event.timeRemaining--;
                
                // Remove expired events
                if (event.timeRemaining <= 0) {
                    event.active = false;
                    activeEvents.splice(i, 1);
                }
            }
        }
        
        // Update events display
        function updateEventsDisplay() {
            const eventsContainer = document.getElementById('active-events');
            if (!eventsContainer) return;
            
            eventsContainer.innerHTML = '';
            
            if (activeEvents.length === 0) {
                eventsContainer.innerHTML = '<p>No active events</p>';
                return;
            }
            
            for (const event of activeEvents) {
                const eventElement = document.createElement('div');
                eventElement.className = 'event-item';
                eventElement.innerHTML = `
                    <strong>${event.name}</strong> (${event.timeRemaining} days remaining)<br>
                    <small>${event.description}</small>
                `;
                eventsContainer.appendChild(eventElement);
            }
        }
        
        // Simulate crime and safety dynamics
        function simulateCrimeAndSafety() {
            // Initialize crime values if not present
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!city[y][x].hasOwnProperty('crime')) {
                        city[y][x].crime = 0;
                    }
                }
            }
            
            // Calculate crime based on economic factors, unemployment, and population density
            for (let i = 0; i < boroughs.length; i++) {
                const borough = boroughs[i];
                
                // Base crime rate inversely related to economic prosperity and employment
                const baseCrimeRate = Math.max(0, 40 - borough.economicValue * 0.3 - borough.employmentRate * 30);
                
                // Allocate security resources based on borough wealth
                const securityResources = (borough.wealthShare / CITY_RESOURCES.totalWealth) * CITY_RESOURCES.security;
                
                // Apply crime to cells
                for (const cell of borough.cells) {
                    // Calculate local factors
                    let localCrime = baseCrimeRate;
                    
                    // Higher population density increases crime
                    localCrime += city[cell.y][cell.x].population * 5;
                    
                    // Poor economic conditions increase crime
                    if (city[cell.y][cell.x].economicValue < 30) {
                        localCrime += (30 - city[cell.y][cell.x].economicValue) * 0.5;
                    }
                    
                    // Slums have higher crime
                    if (city[cell.y][cell.x].type === CELL_TYPES.SLUM) {
                        localCrime *= 1.5;
                    }
                    
                    // Luxury areas attract crime but have more security
                    if (city[cell.y][cell.x].type === CELL_TYPES.LUXURY) {
                        localCrime = localCrime * 1.2 - securityResources * 0.5;
                    }
                    
                    // Security resources reduce crime
                    localCrime -= securityResources * 0.2;
                    
                    // Random fluctuation
                    localCrime *= (0.8 + Math.random() * 0.4);
                    
                    // Cap and set crime rate
                    city[cell.y][cell.x].crime = Math.max(0, Math.min(100, localCrime));
                    
                    // Slums can form in high-crime, low-economic residential areas
                    if (city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL && 
                        city[cell.y][cell.x].crime > 70 && 
                        city[cell.y][cell.x].economicValue < 20 &&
                        Math.random() < 0.05) {
                        city[cell.y][cell.x].type = CELL_TYPES.SLUM;
                    }
                    
                    // Luxury housing can emerge in low-crime, high-economic areas
                    if (city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL && 
                        city[cell.y][cell.x].crime < 20 && 
                        city[cell.y][cell.x].economicValue > 80 &&
                        Math.random() < 0.05) {
                        city[cell.y][cell.x].type = CELL_TYPES.LUXURY;
                    }
                }
                
                // Store borough-wide crime rate
                borough.crimeRate = baseCrimeRate;
                borough.security = securityResources;
            }
        }
        
        // Simulate environmental effects
        function simulateEnvironmentalEffects() {
            // Initialize environment values if not present
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (!city[y][x].hasOwnProperty('environment')) {
                        city[y][x].environment = 50; // Neutral starting point
                    }
                }
            }
            
            // Base environmental factors based on cell types
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cell = city[y][x];
                    let envChange = 0;
                    
                    switch (cell.type) {
                        case CELL_TYPES.PARK:
                            // Parks improve environment
                            envChange = 1.0;
                            break;
                        case CELL_TYPES.WATER:
                            // Water bodies improve environment
                            envChange = 0.8;
                            break;
                        case CELL_TYPES.INDUSTRIAL:
                            // Industrial areas create pollution
                            envChange = -1.5;
                            break;
                        case CELL_TYPES.TRANSPORT:
                            // Transport hubs create some pollution
                            envChange = -0.8;
                            break;
                        case CELL_TYPES.ROAD:
                            // Roads create mild pollution
                            envChange = -0.3;
                            break;
                        case CELL_TYPES.TECH_HUB:
                            // Tech hubs are relatively clean
                            envChange = 0.2;
                            break;
                        case CELL_TYPES.SLUM:
                            // Slums have environmental issues
                            envChange = -1.0;
                            break;
                    }
                    
                    // Apply environmental change
                    cell.environment += envChange * (0.8 + Math.random() * 0.4) / 10;
                    
                    // Environment spreads to neighbors
                    const neighbors = getNeighbors(x, y);
                    for (const n of neighbors) {
                        if (n.x >= 0 && n.x < COLS && n.y >= 0 && n.y < ROWS) {
                            // Pollution spreads more than positive effects
                            const spreadFactor = envChange < 0 ? 0.2 : 0.1;
                            city[n.y][n.x].environment += envChange * spreadFactor * Math.random() / 10;
                        }
                    }
                    
                    // Cap environmental values
                    cell.environment = Math.max(0, Math.min(100, cell.environment));
                }
            }
            
            // Calculate borough environmental quality
            for (let i = 0; i < boroughs.length; i++) {
                const borough = boroughs[i];
                let totalEnvironment = 0;
                
                for (const cell of borough.cells) {
                    totalEnvironment += city[cell.y][cell.x].environment;
                }
                
                borough.environment = totalEnvironment / borough.cells.length;
                
                // Environmental quality affects property values
                if (borough.environment > 70) {
                    for (const cell of borough.cells) {
                        if (city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL || 
                            city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL) {
                            city[cell.y][cell.x].economicValue *= 1.001;
                        }
                    }
                } else if (borough.environment < 30) {
                    for (const cell of borough.cells) {
                        if (city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL || 
                            city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL) {
                            city[cell.y][cell.x].economicValue *= 0.999;
                        }
                    }
                }
            }
        }
        
        // Simulate happiness and wellbeing
        function simulateHappinessWellbeing() {
            // Initialize happiness values if not present
            for (let i = 0; i < boroughs.length; i++) {
                if (!boroughs[i].hasOwnProperty('happiness')) {
                    boroughs[i].happiness = 50; // Neutral starting point
                }
            }
            
            // Calculate happiness based on multiple factors
            for (let i = 0; i < boroughs.length; i++) {
                const borough = boroughs[i];
                
                // Base factors affecting happiness
                const economicFactor = borough.economicValue * 0.3;
                const employmentFactor = borough.employmentRate * 30;
                const environmentFactor = borough.environment * 0.2;
                const crimeFactor = -borough.crimeRate * 0.3;
                const gentrificationFactor = -borough.gentrification * 10;
                
                // Calculate amenities (parks, cultural, education, healthcare)
                let amenities = 0;
                let amenityCount = 0;
                
                for (const cell of borough.cells) {
                    if (city[cell.y][cell.x].type === CELL_TYPES.PARK ||
                        city[cell.y][cell.x].type === CELL_TYPES.CULTURAL ||
                        city[cell.y][cell.x].type === CELL_TYPES.EDUCATION ||
                        city[cell.y][cell.x].type === CELL_TYPES.HEALTHCARE) {
                        amenities += 1;
                        amenityCount++;
                    }
                }
                
                const amenitiesFactor = amenityCount > 0 ? (amenities / amenityCount) * 20 : 0;
                
                // Special cell type factors
                let specialFactors = 0;
                
                // Education improves happiness
                const educationCells = borough.cells.filter(cell => 
                    city[cell.y][cell.x].type === CELL_TYPES.EDUCATION
                ).length;
                specialFactors += educationCells * 2;
                
                // Healthcare improves happiness
                const healthcareCells = borough.cells.filter(cell => 
                    city[cell.y][cell.x].type === CELL_TYPES.HEALTHCARE
                ).length;
                specialFactors += healthcareCells * 2;
                
                // Cultural venues improve happiness
                const culturalCells = borough.cells.filter(cell => 
                    city[cell.y][cell.x].type === CELL_TYPES.CULTURAL
                ).length;
                specialFactors += culturalCells * 1.5;
                
                // Inequality reduces happiness
                const inequalityFactor = -calculateInequalityIndex() * 20;
                
                // Calculate overall happiness
                let newHappiness = 50 + 
                    economicFactor * 0.2 +
                    employmentFactor * 0.2 +
                    environmentFactor * 0.15 +
                    crimeFactor * 0.15 +
                    gentrificationFactor * 0.1 +
                    amenitiesFactor * 0.1 +
                    specialFactors * 0.05 +
                    inequalityFactor * 0.05;
                
                // Slowly adjust happiness (momentum effect)
                borough.happiness = borough.happiness * 0.9 + newHappiness * 0.1;
                
                // Cap happiness values
                borough.happiness = Math.max(0, Math.min(100, borough.happiness));
                
                // Happiness affects economic productivity
                const productivityMultiplier = 0.9 + (borough.happiness / 100) * 0.2;
                
                for (const cell of borough.cells) {
                    if (city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL || 
                        city[cell.y][cell.x].type === CELL_TYPES.INDUSTRIAL ||
                        city[cell.y][cell.x].type === CELL_TYPES.TECH_HUB) {
                        city[cell.y][cell.x].economicValue *= productivityMultiplier;
                    }
                }
                
                // Extreme unhappiness can cause social unrest
                if (borough.happiness < 20 && Math.random() < 0.05) {
                    // Trigger a localized riot event
                    borough.socialUnrest = true;
                    
                    // Decrease economic activity during unrest
                    for (const cell of borough.cells) {
                        city[cell.y][cell.x].economicValue *= 0.95;
                    }
                    
                    console.log(`Social unrest in ${borough.name} due to extreme unhappiness!`);
                } else {
                    borough.socialUnrest = false;
                }
            }
        }
        
        // Develop industry specializations and clusters
        function developSpecializations() {
            // Each borough can develop a specialization over time
            for (let i = 0; i < boroughs.length; i++) {
                const borough = boroughs[i];
                if (!borough) continue;
                
                // Skip if already heavily specialized
                if (borough.specialization && borough.specializationStrength > 0.7) continue;
                
                // Count different cell types to determine potential specializations
                const cellTypeCounts = {};
                for (const cell of borough.cells) {
                    if (!cell || !city[cell.y] || !city[cell.y][cell.x]) continue;
                    
                    const type = city[cell.y][cell.x].type;
                    cellTypeCounts[type] = (cellTypeCounts[type] || 0) + 1;
                }
                
                // Determine possible specializations
                let possibleSpecializations = [];
                
                // Tech Hub specialization
                if ((cellTypeCounts[CELL_TYPES.TECH_HUB] || 0) > 3 || 
                    ((cellTypeCounts[CELL_TYPES.EDUCATION] || 0) > 2 && (cellTypeCounts[CELL_TYPES.COMMERCIAL] || 0) > 5)) {
                    possibleSpecializations.push({
                        name: "Technology Hub",
                        type: CELL_TYPES.TECH_HUB,
                        score: ((cellTypeCounts[CELL_TYPES.TECH_HUB] || 0) * 2) + ((cellTypeCounts[CELL_TYPES.EDUCATION] || 0) * 1)
                    });
                }
                
                // Cultural District specialization
                if ((cellTypeCounts[CELL_TYPES.CULTURAL] || 0) > 2 || 
                    ((cellTypeCounts[CELL_TYPES.PARK] || 0) > 3 && (cellTypeCounts[CELL_TYPES.COMMERCIAL] || 0) > 4)) {
                    possibleSpecializations.push({
                        name: "Cultural District",
                        type: CELL_TYPES.CULTURAL,
                        score: ((cellTypeCounts[CELL_TYPES.CULTURAL] || 0) * 2) + ((cellTypeCounts[CELL_TYPES.PARK] || 0) * 0.5)
                    });
                }
                
                // Financial Center specialization
                if ((cellTypeCounts[CELL_TYPES.COMMERCIAL] || 0) > 8 && borough.economicValue > 70) {
                    possibleSpecializations.push({
                        name: "Financial District",
                        type: CELL_TYPES.COMMERCIAL,
                        score: ((cellTypeCounts[CELL_TYPES.COMMERCIAL] || 0) * 1) + (borough.economicValue * 0.1)
                    });
                }
                
                // Industrial Zone specialization
                if ((cellTypeCounts[CELL_TYPES.INDUSTRIAL] || 0) > 6) {
                    possibleSpecializations.push({
                        name: "Industrial Zone",
                        type: CELL_TYPES.INDUSTRIAL,
                        score: ((cellTypeCounts[CELL_TYPES.INDUSTRIAL] || 0) * 1.5)
                    });
                }
                
                // Residential Community specialization
                if ((cellTypeCounts[CELL_TYPES.RESIDENTIAL] || 0) > 10 && 
                    (cellTypeCounts[CELL_TYPES.PARK] || 0) > 3 && 
                    borough.environment > 60) {
                    possibleSpecializations.push({
                        name: "Residential Community",
                        type: CELL_TYPES.RESIDENTIAL,
                        score: ((cellTypeCounts[CELL_TYPES.RESIDENTIAL] || 0) * 0.8) + ((cellTypeCounts[CELL_TYPES.PARK] || 0) * 1) + (borough.environment * 0.1)
                    });
                }
                
                // Luxury District specialization
                if ((cellTypeCounts[CELL_TYPES.LUXURY] || 0) > 3 && borough.wealth > 70) {
                    possibleSpecializations.push({
                        name: "Luxury District",
                        type: CELL_TYPES.LUXURY,
                        score: ((cellTypeCounts[CELL_TYPES.LUXURY] || 0) * 2) + (borough.wealth * 0.1)
                    });
                }
                
                // Healthcare Hub specialization
                if ((cellTypeCounts[CELL_TYPES.HEALTHCARE] || 0) > 2) {
                    possibleSpecializations.push({
                        name: "Healthcare Hub",
                        type: CELL_TYPES.HEALTHCARE,
                        score: ((cellTypeCounts[CELL_TYPES.HEALTHCARE] || 0) * 3)
                    });
                }
                
                // Educational Center specialization
                if ((cellTypeCounts[CELL_TYPES.EDUCATION] || 0) > 2) {
                    possibleSpecializations.push({
                        name: "Educational Center",
                        type: CELL_TYPES.EDUCATION,
                        score: ((cellTypeCounts[CELL_TYPES.EDUCATION] || 0) * 3)
                    });
                }
                
                // Select the strongest specialization
                if (possibleSpecializations.length > 0) {
                    // Sort by score
                    possibleSpecializations.sort((a, b) => b.score - a.score);
                    const topSpecialization = possibleSpecializations[0];
                    
                    // If it's a new specialization or stronger than current
                    if (!borough.specialization || 
                        (borough.specialization !== topSpecialization.name && topSpecialization.score > borough.specializationStrength * 10)) {
                        borough.specialization = topSpecialization.name;
                        borough.specializationType = topSpecialization.type;
                        borough.specializationStrength = Math.min(1.0, topSpecialization.score / 20);
                        
                        // Apply specialization effects
                        applySpecializationEffects(borough);
                        
                        console.log(`${borough.name} has developed a specialization: ${borough.specialization} (${borough.specializationStrength.toFixed(2)})`);
                    } else if (borough.specialization === topSpecialization.name) {
                        // Strengthen existing specialization
                        borough.specializationStrength = Math.min(1.0, (borough.specializationStrength * 0.9) + (topSpecialization.score / 200));
                    }
                }
            }
        }
        
        // Apply effects from borough specializations
        function applySpecializationEffects(borough) {
            if (!borough.specialization || borough.specializationStrength <= 0) return;
            
            const strength = borough.specializationStrength;
            
            switch (borough.specialization) {
                case "Technology Hub":
                    // Tech hubs get economic boosts and attract talent
                    borough.economicValue *= (1 + strength * 0.1);
                    borough.talentsAllocated += Math.floor(strength * 10);
                    
                    // Occasional conversion of commercial to tech hubs
                    if (Math.random() < strength * 0.1) {
                        const commercialCells = borough.cells.filter(cell => 
                            city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL
                        );
                        
                        if (commercialCells.length > 0) {
                            const cell = commercialCells[Math.floor(Math.random() * commercialCells.length)];
                            city[cell.y][cell.x].type = CELL_TYPES.TECH_HUB;
                        }
                    }
                    break;
                    
                case "Cultural District":
                    // Cultural districts boost happiness and tourism
                    borough.happiness += strength * 5;
                    borough.economicValue *= (1 + strength * 0.05);
                    
                    // Occasional conversion to cultural venues
                    if (Math.random() < strength * 0.1) {
                        const commercialCells = borough.cells.filter(cell => 
                            city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL
                        );
                        
                        if (commercialCells.length > 0) {
                            const cell = commercialCells[Math.floor(Math.random() * commercialCells.length)];
                            city[cell.y][cell.x].type = CELL_TYPES.CULTURAL;
                        }
                    }
                    break;
                    
                case "Financial District":
                    // Financial districts boost wealth
                    borough.wealthShare *= (1 + strength * 0.15);
                    borough.economicValue *= (1 + strength * 0.08);
                    
                    // More high-value commercial activity
                    for (const cell of borough.cells) {
                        if (city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL) {
                            city[cell.y][cell.x].economicValue *= (1 + strength * 0.05);
                        }
                    }
                    break;
                    
                case "Industrial Zone":
                    // Industrial zones provide more jobs but may hurt environment
                    borough.jobsAllocated += Math.floor(strength * 15);
                    borough.environment -= strength * 3;
                    
                    // More industrial growth
                    if (Math.random() < strength * 0.15) {
                        const emptyCells = borough.cells.filter(cell => 
                            city[cell.y][cell.x].type === CELL_TYPES.EMPTY
                        );
                        
                        if (emptyCells.length > 0) {
                            const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                            city[cell.y][cell.x].type = CELL_TYPES.INDUSTRIAL;
                        }
                    }
                    break;
                    
                case "Residential Community":
                    // Residential communities have higher quality of life
                    borough.happiness += strength * 8;
                    borough.environment += strength * 3;
                    
                    // Property values increase
                    for (const cell of borough.cells) {
                        if (city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL) {
                            city[cell.y][cell.x].economicValue *= (1 + strength * 0.03);
                        }
                    }
                    break;
                    
                case "Luxury District":
                    // Luxury districts have very high property values
                    borough.wealthShare *= (1 + strength * 0.2);
                    borough.gentrification += strength * 0.1;
                    
                    // Occasional conversion to luxury
                    if (Math.random() < strength * 0.15) {
                        const residentialCells = borough.cells.filter(cell => 
                            city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL && 
                            city[cell.y][cell.x].economicValue > 70
                        );
                        
                        if (residentialCells.length > 0) {
                            const cell = residentialCells[Math.floor(Math.random() * residentialCells.length)];
                            city[cell.y][cell.x].type = CELL_TYPES.LUXURY;
                        }
                    }
                    break;
                    
                case "Healthcare Hub":
                    // Healthcare hubs improve well-being
                    borough.happiness += strength * 6;
                    
                    // Boost healthcare-related employment
                    borough.jobsAllocated += Math.floor(strength * 8);
                    borough.talentsAllocated += Math.floor(strength * 5);
                    break;
                    
                case "Educational Center":
                    // Educational centers boost talent
                    borough.talentsAllocated += Math.floor(strength * 15);
                    borough.happiness += strength * 4;
                    
                    // Long-term economic boost
                    if (Math.random() < strength * 0.3) {
                        borough.economicValue *= (1 + strength * 0.02);
                    }
                    break;
            }
        }
        
        // Update global simulation statistics
        function updateSimulationStats() {
            // Find economic districts
            const economicDistricts = findEconomicDistricts();
            document.getElementById('district-count').textContent = economicDistricts.length;
            
            // Calculate average economy
            let totalEconomy = 0;
            for (const borough of boroughs) {
                totalEconomy += borough.economicValue;
            }
            const avgEconomy = totalEconomy / boroughs.length;
            document.getElementById('avg-economy').textContent = avgEconomy.toFixed(1);
            
            // Calculate population density
            let totalPopulation = 0;
            for (const borough of boroughs) {
                totalPopulation += borough.population;
            }
            const density = totalPopulation / (ROWS * COLS);
            document.getElementById('population-density').textContent = density.toFixed(2);
        }
        
        // Reassign work locations based on emerging economic districts
        function reassignWorkLocations() {
            // Find economic districts
            const economicDistricts = findEconomicDistricts();
            if (economicDistricts.length === 0) return;
            
            // Create a flat list of all commercial cells from districts
            const commercialCells = [];
            for (const district of economicDistricts) {
                for (const cell of district.cells) {
                    if (city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL || 
                        city[cell.y][cell.x].type === CELL_TYPES.INDUSTRIAL) {
                        commercialCells.push(cell);
                    }
                }
            }
            
            if (commercialCells.length === 0) return;
            
            // Reassign 5% of people to new work locations
            const peopleToReassign = Math.ceil(people.length * 0.05);
            for (let i = 0; i < peopleToReassign; i++) {
                const personIndex = Math.floor(Math.random() * people.length);
                const person = people[personIndex];
                
                // Pick a random commercial cell as new work location
                const newWorkCell = commercialCells[Math.floor(Math.random() * commercialCells.length)];
                person.work = {
                    borough: city[newWorkCell.y][newWorkCell.x].borough,
                    x: newWorkCell.x,
                    y: newWorkCell.y
                };
            }
        }
        
        // Move people to work with preference for roads and transport
        function movePeopleToWork(probability) {
            for (const person of people) {
                if (!person || !person.currentLocation || !person.work) continue;
                
                if (Math.random() < probability) {
                    if (person.currentLocation.x !== person.work.x || person.currentLocation.y !== person.work.y) {
                        // Get possible directions
                        const dx = Math.sign(person.work.x - person.currentLocation.x);
                        const dy = Math.sign(person.work.y - person.currentLocation.y);
                        
                        // Define possible moves in order of preference
                        const possibleMoves = [];
                        
                        // Add horizontal and vertical moves if they get us closer
                        if (dx !== 0) possibleMoves.push({dx, dy: 0});
                        if (dy !== 0) possibleMoves.push({dx: 0, dy});
                        
                        // Add diagonal move if both x and y differ
                        if (dx !== 0 && dy !== 0) possibleMoves.push({dx, dy});
                        
                        // Add random movement options as fallback
                        possibleMoves.push({dx: Math.random() < 0.5 ? 1 : -1, dy: 0});
                        possibleMoves.push({dx: 0, dy: Math.random() < 0.5 ? 1 : -1});
                        
                        // Try moves in order of preference
                        let moved = false;
                        for (const move of possibleMoves) {
                            const newX = person.currentLocation.x + move.dx;
                            const newY = person.currentLocation.y + move.dy;
                            
                            // Skip if out of bounds
                            if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) continue;
                            if (!city[newY] || !city[newY][newX]) continue;
                            
                            // Skip water cells
                            if (city[newY][newX].type === CELL_TYPES.WATER) continue;
                            
                            // Prefer roads and transport routes (higher probability)
                            if (city[newY][newX].type === CELL_TYPES.ROAD || 
                                city[newY][newX].type === CELL_TYPES.TRANSPORT) {
                                if (Math.random() < 0.9) {
                                    person.currentLocation.x = newX;
                                    person.currentLocation.y = newY;
                                    moved = true;
                                    break;
                                }
                            } else {
                                // Non-road cells have lower probability
                                if (Math.random() < 0.5) {
                                    person.currentLocation.x = newX;
                                    person.currentLocation.y = newY;
                                    moved = true;
                                    break;
                                }
                            }
                        }
                        
                        // If no move was successful, just make a direct move toward destination
                        if (!moved) {
                            if (Math.random() < 0.5 && dx !== 0) {
                                person.currentLocation.x += dx;
                            } else if (dy !== 0) {
                                person.currentLocation.y += dy;
                            }
                            
                            // Ensure we stay within bounds
                            person.currentLocation.x = Math.max(0, Math.min(COLS - 1, person.currentLocation.x));
                            person.currentLocation.y = Math.max(0, Math.min(ROWS - 1, person.currentLocation.y));
                        }
                    }
                }
            }
        }
        
        // Move people to home with preference for roads and transport
        function movePeopleToHome(probability) {
            for (const person of people) {
                if (!person || !person.currentLocation || !person.home) continue;
                
                if (Math.random() < probability) {
                    if (person.currentLocation.x !== person.home.x || person.currentLocation.y !== person.home.y) {
                        // Get possible directions
                        const dx = Math.sign(person.home.x - person.currentLocation.x);
                        const dy = Math.sign(person.home.y - person.currentLocation.y);
                        
                        // Define possible moves in order of preference
                        const possibleMoves = [];
                        
                        // Add horizontal and vertical moves if they get us closer
                        if (dx !== 0) possibleMoves.push({dx, dy: 0});
                        if (dy !== 0) possibleMoves.push({dx: 0, dy});
                        
                        // Add diagonal move if both x and y differ
                        if (dx !== 0 && dy !== 0) possibleMoves.push({dx, dy});
                        
                        // Add random movement options as fallback
                        possibleMoves.push({dx: Math.random() < 0.5 ? 1 : -1, dy: 0});
                        possibleMoves.push({dx: 0, dy: Math.random() < 0.5 ? 1 : -1});
                        
                        // Try moves in order of preference
                        let moved = false;
                        for (const move of possibleMoves) {
                            const newX = person.currentLocation.x + move.dx;
                            const newY = person.currentLocation.y + move.dy;
                            
                            // Skip if out of bounds
                            if (newX < 0 || newX >= COLS || newY < 0 || newY >= ROWS) continue;
                            if (!city[newY] || !city[newY][newX]) continue;
                            
                            // Skip water cells
                            if (city[newY][newX].type === CELL_TYPES.WATER) continue;
                            
                            // Prefer roads and transport routes (higher probability)
                            if (city[newY][newX].type === CELL_TYPES.ROAD || 
                                city[newY][newX].type === CELL_TYPES.TRANSPORT) {
                                if (Math.random() < 0.9) {
                                    person.currentLocation.x = newX;
                                    person.currentLocation.y = newY;
                                    moved = true;
                                    break;
                                }
                            } else {
                                // Non-road cells have lower probability
                                if (Math.random() < 0.5) {
                                    person.currentLocation.x = newX;
                                    person.currentLocation.y = newY;
                                    moved = true;
                                    break;
                                }
                            }
                        }
                        
                        // If no move was successful, just make a direct move toward destination
                        if (!moved) {
                            if (Math.random() < 0.5 && dx !== 0) {
                                person.currentLocation.x += dx;
                            } else if (dy !== 0) {
                                person.currentLocation.y += dy;
                            }
                            
                            // Ensure we stay within bounds
                            person.currentLocation.x = Math.max(0, Math.min(COLS - 1, person.currentLocation.x));
                            person.currentLocation.y = Math.max(0, Math.min(ROWS - 1, person.currentLocation.y));
                        }
                    }
                }
            }
        }
        
        // Simulate work activities
        function simulateWorkActivities() {
            for (const person of people) {
                if (person.isWorking && 
                    person.currentLocation.x === person.work.x && 
                    person.currentLocation.y === person.work.y) {
                    
                    // Produce economic value based on skill level
                    const cell = city[person.currentLocation.y][person.currentLocation.x];
                    cell.economicValue += person.skillLevel * 0.5;
                    
                    // Cap economic value
                    cell.economicValue = Math.min(cell.economicValue, 100);
                }
            }
        }
        
        // Simulate home activities
        function simulateHomeActivities() {
            for (const person of people) {
                if (person.currentLocation.x === person.home.x && 
                    person.currentLocation.y === person.home.y) {
                    
                    // Consume economic value based on spending habits
                    const spendingAmount = person.wealth * person.spendingHabit * 0.01;
                    
                    // Distribute spending to nearby commercial cells
                    const homeBorough = person.home.borough;
                    const commercialCells = boroughs[homeBorough].cells.filter(cell => 
                        city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL
                    );
                    
                    if (commercialCells.length > 0) {
                        const randomCellIndex = Math.floor(Math.random() * commercialCells.length);
                        const targetCell = commercialCells[randomCellIndex];
                        city[targetCell.y][targetCell.x].economicValue += spendingAmount;
                        
                        // Cap economic value
                        city[targetCell.y][targetCell.x].economicValue = Math.min(city[targetCell.y][targetCell.x].economicValue, 100);
                    }
                }
            }
        }
        
        // Calculate economic effects with Game of Life-like rules and finite resources
        function calculateEconomicEffects() {
            // Track transport route usage
            const transportUsage = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            
            // Count people on each cell for transport usage
            for (const person of people) {
                const { x, y } = person.currentLocation;
                transportUsage[y][x]++;
            }
            
            // Apply transport usage to cell transport values
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    if (city[y][x].type === CELL_TYPES.ROAD || city[y][x].type === CELL_TYPES.TRANSPORT) {
                        // Routes with higher usage get higher transport values
                        const usage = transportUsage[y][x];
                        if (usage > 0) {
                            city[y][x].transport = Math.min(100, city[y][x].transport + (usage * 0.5));
                        } else {
                            // Slowly reduce transport value if not used
                            city[y][x].transport = Math.max(10, city[y][x].transport * 0.995);
                        }
                    }
                }
            }
            
            // Create a copy of the city to apply Game of Life-like rules
            const newEconomicValues = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            const newCellTypes = Array(ROWS).fill().map(() => Array(COLS).fill(null));
            
            // Calculate current economic power distribution for zero-sum competition
            const boroughEconomicPower = [];
            const totalEconomicPower = boroughs.reduce((sum, borough) => {
                const power = borough.economicValue * borough.population * (0.5 + borough.wealth/100);
                boroughEconomicPower.push(power);
                return sum + power;
            }, 0);
            
            // Calculate wealth and resource allocations based on economic power
            const wealthShares = boroughEconomicPower.map(power => power / totalEconomicPower);
            const jobShares = [...wealthShares];
            const talentShares = [...wealthShares];
            const investmentShares = [...wealthShares];
            
            // Apply Matthew Effect (rich get richer) - power law distribution
            for (let i = 0; i < wealthShares.length; i++) {
                wealthShares[i] = Math.pow(wealthShares[i], 0.8); // Less severe inequality 
                jobShares[i] = Math.pow(jobShares[i], 0.7);       // Jobs slightly more evenly distributed
                talentShares[i] = Math.pow(talentShares[i], 0.6); // Talent more evenly distributed
                investmentShares[i] = Math.pow(wealthShares[i], 1.2); // Investment more concentrated
            }
            
            // Normalize shares to ensure they sum to 1
            const normalizeShares = (shares) => {
                const total = shares.reduce((sum, share) => sum + share, 0);
                return shares.map(share => share / total);
            };
            
            const normalizedWealthShares = normalizeShares(wealthShares);
            const normalizedJobShares = normalizeShares(jobShares);
            const normalizedTalentShares = normalizeShares(talentShares);
            const normalizedInvestmentShares = normalizeShares(investmentShares);
            
            // Update borough resource allocations
            for (let i = 0; i < boroughs.length; i++) {
                boroughs[i].wealthShare = normalizedWealthShares[i] * CITY_RESOURCES.totalWealth;
                boroughs[i].jobsAllocated = Math.floor(normalizedJobShares[i] * CITY_RESOURCES.jobs);
                boroughs[i].talentsAllocated = Math.floor(normalizedTalentShares[i] * CITY_RESOURCES.talents);
                boroughs[i].investmentAllocated = normalizedInvestmentShares[i] * CITY_RESOURCES.investmentCapital;
                
                // Calculate opportunity score - higher means more economic opportunity
                boroughs[i].opportunity = (boroughs[i].jobsAllocated / Math.max(1, boroughs[i].population)) * 100;
                
                // Calculate gentrification pressure - higher wealth relative to population means higher gentrification
                boroughs[i].gentrification = (boroughs[i].wealthShare / Math.max(10, boroughs[i].population)) * 0.1;
            }
            
            // Apply cellular automata rules for economic evolution
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    // Skip water cells
                    if (city[y][x].type === CELL_TYPES.WATER) {
                        newEconomicValues[y][x] = city[y][x].economicValue;
                        newCellTypes[y][x] = city[y][x].type;
                        continue;
                    }
                    
                    const boroughId = city[y][x].borough;
                    const borough = boroughs[boroughId];
                    
                    // Count neighbors of each type
                    const neighbors = getNeighbors(x, y);
                    const neighborTypes = {};
                    let totalNeighborEconomicValue = 0;
                    
                    for (const n of neighbors) {
                        if (n.x >= 0 && n.x < COLS && n.y >= 0 && n.y < ROWS) {
                            const type = city[n.y][n.x].type;
                            neighborTypes[type] = (neighborTypes[type] || 0) + 1;
                            totalNeighborEconomicValue += city[n.y][n.x].economicValue;
                        }
                    }
                    
                    // Calculate average neighbor economic value
                    const avgNeighborEconomicValue = totalNeighborEconomicValue / Math.max(1, neighbors.length);
                    
                    // Apply economic diffusion based on neighborhood
                    const currentValue = city[y][x].economicValue;
                    
                    // Economic cells influence neighbors more strongly
                    const economicInfluence = (
                        (neighborTypes[CELL_TYPES.COMMERCIAL] || 0) * 1.5 + 
                        (neighborTypes[CELL_TYPES.INDUSTRIAL] || 0) * 1.2 +
                        (neighborTypes[CELL_TYPES.GOVERNMENTAL] || 0) * 1.0
                    ) * 0.1;
                    
                    // Transportation increases economic influence
                    const transportMultiplier = 1.0 + (city[y][x].transport / 200);
                    
                    // Higher population density boosts economic activity
                    const populationFactor = 1.0 + (city[y][x].population / 10);
                    
                    // Resource factors affect growth
                    const jobFactor = Math.min(1.5, Math.max(0.5, borough.jobsAllocated / (borough.population * 10)));
                    const talentFactor = Math.min(1.3, Math.max(0.7, borough.talentsAllocated / 100));
                    const investmentFactor = Math.min(1.5, Math.max(0.5, borough.investmentAllocated / 1000));
                    
                    // Apply zero-sum competition: areas with higher economic values drain resources from poorer areas
                    let competitionFactor = 1.0;
                    if (currentValue > 50) {
                        // Rich areas get richer at the expense of poorer areas
                        competitionFactor = 1.1;
                    } else if (currentValue < 30) {
                        // Poor areas struggle more due to resource drain
                        competitionFactor = 0.9;
                    }
                    
                    // Calculate new economic value with diffusion
                    let newValue = currentValue * 0.7 + avgNeighborEconomicValue * 0.3;
                    
                    // Apply factors
                    newValue *= (1.0 + economicInfluence);
                    newValue *= transportMultiplier;
                    newValue *= populationFactor;
                    newValue *= jobFactor;
                    newValue *= talentFactor;
                    newValue *= investmentFactor;
                    newValue *= competitionFactor;
                    
                    // Apply random fluctuation (economic "noise") - more variance for realism
                    newValue *= (0.9 + Math.random() * 0.2);
                    
                    // Apply gentrification effects
                    if (borough.gentrification > 0.5 && city[y][x].type === CELL_TYPES.RESIDENTIAL) {
                        // Gentrification boosts property values but can displace population
                        newValue *= (1 + borough.gentrification * 0.1);
                        
                        // Population displacement from gentrification
                        if (Math.random() < borough.gentrification * 0.05 && city[y][x].population > 1) {
                            city[y][x].population *= 0.95;
                        }
                    }
                    
                    // Cap and store new value
                    newEconomicValues[y][x] = Math.min(100, Math.max(0, newValue));
                    
                    // Cell type evolution
                    const currentType = city[y][x].type;
                    let newType = currentType;
                    
                    // Empty cells may develop into something based on surroundings
                    if (currentType === CELL_TYPES.EMPTY) {
                        // Resource constraints - limit new development based on available resources
                        if (borough.investmentAllocated > 100) {
                            // Near commercial cells tend to become commercial (economic districts emerge)
                            if ((neighborTypes[CELL_TYPES.COMMERCIAL] || 0) >= 3 && newValue > 40) {
                                newType = CELL_TYPES.COMMERCIAL;
                                borough.investmentAllocated -= 30; // Cost to develop
                            } 
                            // Near residential with good economy may become commercial
                            else if ((neighborTypes[CELL_TYPES.RESIDENTIAL] || 0) >= 3 && newValue > 50) {
                                newType = CELL_TYPES.COMMERCIAL;
                                borough.investmentAllocated -= 25; // Cost to develop
                            }
                            // Near industrial may become industrial
                            else if ((neighborTypes[CELL_TYPES.INDUSTRIAL] || 0) >= 3 && newValue > 45) {
                                newType = CELL_TYPES.INDUSTRIAL;
                                borough.investmentAllocated -= 40; // Cost to develop
                            }
                            // Undeveloped area with people may become residential
                            else if (transportUsage[y][x] > 0 && newValue > 20) {
                                newType = CELL_TYPES.RESIDENTIAL;
                                borough.investmentAllocated -= 15; // Cost to develop
                            }
                            // Between developed areas may become parks
                            else if (neighbors.length > 4 && newValue > 30 && Math.random() < 0.1) {
                                newType = CELL_TYPES.PARK;
                                borough.investmentAllocated -= 10; // Cost to develop
                            }
                        }
                    }
                    // Commercial areas may grow stronger or weaken
                    else if (currentType === CELL_TYPES.COMMERCIAL) {
                        // Commercial areas that don't thrive may decline - more severe in resource-constrained areas
                        if (newValue < 20 || borough.jobsAllocated < 10) {
                            if (Math.random() < 0.2) {
                                newType = CELL_TYPES.EMPTY;
                                // When businesses close, jobs are lost
                                borough.jobsAllocated = Math.max(0, borough.jobsAllocated - 5);
                            }
                        }
                    }
                    // Industrial areas evolve based on economy
                    else if (currentType === CELL_TYPES.INDUSTRIAL) {
                        // Failed industrial areas decline - more severely without necessary resources
                        if (newValue < 15 || borough.talentsAllocated < 5) {
                            if (Math.random() < 0.15) {
                                newType = CELL_TYPES.EMPTY;
                                // When industry fails, jobs and talents are lost
                                borough.jobsAllocated = Math.max(0, borough.jobsAllocated - 8);
                                borough.talentsAllocated = Math.max(0, borough.talentsAllocated - 2);
                            }
                        }
                    }
                    // Residential areas can decline or gentrify
                    else if (currentType === CELL_TYPES.RESIDENTIAL) {
                        // High gentrification can convert some residential to commercial (luxury retail)
                        if (borough.gentrification > 0.8 && newValue > 70 && Math.random() < 0.05) {
                            newType = CELL_TYPES.COMMERCIAL;
                        }
                        // Severe economic depression can lead to abandoned housing
                        else if (newValue < 10 && Math.random() < 0.1) {
                            newType = CELL_TYPES.EMPTY;
                        }
                    }
                    
                    // Store the new cell type
                    newCellTypes[y][x] = newType;
                }
            }
            
            // Update city with new values
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    // Update economic value
                    city[y][x].economicValue = newEconomicValues[y][x];
                    
                    // Update cell type if it changed
                    if (newCellTypes[y][x] !== null && city[y][x].type !== CELL_TYPES.ROAD && 
                        city[y][x].type !== CELL_TYPES.WATER && city[y][x].type !== CELL_TYPES.TRANSPORT) {
                        city[y][x].type = newCellTypes[y][x];
                    }
                    
                    const boroughId = city[y][x].borough;
                    const borough = boroughs[boroughId];
                    
                    // Growth affects population based on economic prosperity and available jobs
                    if (city[y][x].type === CELL_TYPES.RESIDENTIAL) {
                        // Economically thriving areas with jobs attract more people
                        if (city[y][x].economicValue > 50 && borough.jobsAllocated > borough.population * 0.5) {
                            city[y][x].population = Math.min(5, city[y][x].population * 1.002);
                        } 
                        // Poor economic areas lose population to better boroughs
                        else if (city[y][x].economicValue < 20 || borough.jobsAllocated < borough.population * 0.3) {
                            city[y][x].population = Math.max(0.1, city[y][x].population * 0.998);
                            
                            // People migrating to better areas
                            if (Math.random() < 0.02) {
                                // Find a better borough to migrate to
                                let targetBoroughIndex = -1;
                                let bestOpportunity = borough.opportunity;
                                
                                for (let i = 0; i < boroughs.length; i++) {
                                    if (i !== boroughId && boroughs[i].opportunity > bestOpportunity * 1.2) {
                                        targetBoroughIndex = i;
                                        bestOpportunity = boroughs[i].opportunity;
                                    }
                                }
                                
                                if (targetBoroughIndex >= 0) {
                                    // Find residential cell in target borough
                                    const targetCells = boroughs[targetBoroughIndex].cells.filter(
                                        cell => city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL
                                    );
                                    
                                    if (targetCells.length > 0) {
                                        const targetCell = targetCells[Math.floor(Math.random() * targetCells.length)];
                                        
                                        // Move population (migration)
                                        const migrationAmount = Math.min(0.2, city[y][x].population * 0.1);
                                        city[y][x].population -= migrationAmount;
                                        city[targetCell.y][targetCell.x].population += migrationAmount;
                                    }
                                }
                            }
                        }
                    }
                    
                    // Commercial and industrial areas have employees based on economic value and available jobs
                    if (city[y][x].type === CELL_TYPES.COMMERCIAL || city[y][x].type === CELL_TYPES.INDUSTRIAL) {
                        const jobCap = Math.min(3, borough.jobsAllocated / 100);
                        city[y][x].population = Math.min(jobCap, city[y][x].economicValue / 40);
                    }
                }
            }
            
            // Calculate borough-wide effects after cell updates
            for (let i = 0; i < boroughs.length; i++) {
                const borough = boroughs[i];
                let totalEconomicValue = 0;
                let totalPopulation = 0;
                let cellCount = 0;
                let commercialCount = 0;
                let industrialCount = 0;
                let residentialCount = 0;
                
                // Sum up values across all cells
                for (const cell of borough.cells) {
                    totalEconomicValue += city[cell.y][cell.x].economicValue;
                    totalPopulation += city[cell.y][cell.x].population;
                    cellCount++;
                    
                    // Count cell types
                    if (city[cell.y][cell.x].type === CELL_TYPES.COMMERCIAL) commercialCount++;
                    if (city[cell.y][cell.x].type === CELL_TYPES.INDUSTRIAL) industrialCount++;
                    if (city[cell.y][cell.x].type === CELL_TYPES.RESIDENTIAL) residentialCount++;
                }
                
                // Update borough statistics
                borough.economicValue = totalEconomicValue / cellCount;
                borough.population = totalPopulation;
                
                // Update employment rate based on available jobs vs population
                borough.employmentRate = Math.min(1, Math.max(0.2, borough.jobsAllocated / Math.max(1, borough.population)));
                
                // Update business count based on economic activity and commercial cell count
                borough.businessCount = Math.floor(commercialCount * (0.5 + borough.economicValue / 200));
                
                // Calculate wealth effects
                borough.wealth = 30 + (borough.wealthShare / 10000);
                
                // Borough status label based on economic conditions
                if (borough.economicValue < 20) borough.status = "Declining";
                else if (borough.economicValue < 40) borough.status = "Struggling";
                else if (borough.economicValue < 60) borough.status = "Stable";
                else if (borough.economicValue < 80) borough.status = "Prosperous";
                else borough.status = "Wealthy";
                
                // Spread economic effects to neighboring boroughs through transport connections
                const connections = borough.transportConnections;
                for (const connection of connections) {
                    const targetBorough = boroughs[connection.targetId];
                    
                    // Calculate actual route usage (people traveling between boroughs)
                    let routeUsage = 0;
                    for (const person of people) {
                        if ((person.home.borough === i && person.work.borough === connection.targetId) ||
                            (person.work.borough === i && person.home.borough === connection.targetId)) {
                            routeUsage++;
                        }
                    }
                    
                    // Higher route usage means stronger economic connections
                    const usageMultiplier = 1 + (routeUsage / 50);
                    
                    // Resource transfer between connected boroughs (zero-sum)
                    if (borough.economicValue > targetBorough.economicValue * 1.5) {
                        // Rich boroughs drain resources from poor boroughs
                        const resourceDrain = Math.min(5, targetBorough.investmentAllocated * 0.01);
                        targetBorough.investmentAllocated -= resourceDrain;
                        borough.investmentAllocated += resourceDrain;
                        
                        // Limited economic benefit to poor borough
                        const economicSpread = borough.economicValue * 0.01 * connection.quality * usageMultiplier;
                        targetBorough.economicValue += economicSpread;
                    } else if (targetBorough.economicValue > borough.economicValue * 1.5) {
                        // Poor boroughs get limited benefit from connection to rich boroughs
                        const economicSpread = targetBorough.economicValue * 0.02 * connection.quality * usageMultiplier;
                        borough.economicValue += economicSpread;
                    } else {
                        // Similar boroughs engage in more balanced exchange
                        const economicSpread = borough.economicValue * 0.03 * connection.quality * usageMultiplier;
                        targetBorough.economicValue += economicSpread;
                    }
                    
                    // Cap economic values
                    targetBorough.economicValue = Math.min(100, targetBorough.economicValue);
                    borough.economicValue = Math.min(100, borough.economicValue);
                    
                    // Improve connection quality based on usage
                    connection.quality = Math.min(1, connection.quality + (routeUsage * 0.0001));
                }
            }
            
            // Update simulation stats display
            document.getElementById('total-wealth').textContent = Math.floor(CITY_RESOURCES.totalWealth).toLocaleString();
            document.getElementById('total-jobs').textContent = CITY_RESOURCES.jobs.toLocaleString();
            document.getElementById('inequality-index').textContent = calculateInequalityIndex().toFixed(2);
        }
        
        // Calculate Gini coefficient-like inequality index (0-1, higher = more inequality)
        function calculateInequalityIndex() {
            if (boroughs.length <= 1) return 0;
            
            const wealthValues = boroughs.map(b => b.wealthShare);
            wealthValues.sort((a, b) => a - b);
            
            let sumDifferences = 0;
            for (let i = 0; i < wealthValues.length; i++) {
                for (let j = 0; j < wealthValues.length; j++) {
                    sumDifferences += Math.abs(wealthValues[i] - wealthValues[j]);
                }
            }
            
            // Normalize to 0-1 range
            return sumDifferences / (2 * wealthValues.length * wealthValues.reduce((a, b) => a + b, 0));
        }
        
        // Get the neighbors of a cell
        function getNeighbors(x, y) {
            const neighbors = [];
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    if (dx === 0 && dy === 0) continue;
                    neighbors.push({x: x + dx, y: y + dy});
                }
            }
            return neighbors;
        }
        
        // Update borough statistics display
        function updateBoroughStats() {
            boroughStatsContainer.innerHTML = '';
            
            // Sort boroughs by economic value to highlight inequality
            const boroughIndices = [...Array(boroughs.length).keys()];
            boroughIndices.sort((a, b) => boroughs[b].economicValue - boroughs[a].economicValue);
            
            for (const i of boroughIndices) {
                const borough = boroughs[i];
                const statsDiv = document.createElement('div');
                statsDiv.className = 'borough-stat';
                statsDiv.style.borderLeft = `4px solid ${borough.color}`;
                
                // Set background color based on borough status
                let bgColor = '';
                if (borough.economicValue < 20) bgColor = 'rgba(0, 0, 100, 0.1)'; // Declining
                else if (borough.economicValue < 40) bgColor = 'rgba(75, 200, 200, 0.1)'; // Struggling
                else if (borough.economicValue < 60) bgColor = 'rgba(255, 255, 0, 0.1)'; // Average
                else if (borough.economicValue < 80) bgColor = 'rgba(255, 100, 0, 0.1)'; // Prosperous
                else bgColor = 'rgba(150, 0, 120, 0.1)'; // Wealthy
                
                statsDiv.style.backgroundColor = bgColor;
                
                // Set tooltip data
                statsDiv.dataset.borough = i;
                
                statsDiv.innerHTML = `
                    <strong>${borough.name}</strong><br>
                    Economy: ${borough.economicValue.toFixed(1)}<br>
                    <small>Status: ${borough.status}</small>
                `;
                
                statsDiv.addEventListener('click', () => showBoroughDetails(i));
                
                boroughStatsContainer.appendChild(statsDiv);
            }
        }
        
        // Show detailed borough statistics
        function showBoroughDetails(boroughId) {
            const borough = boroughs[boroughId];
            
            // Calculate stats for resource competition visualization
            const totalWealth = CITY_RESOURCES.totalWealth;
            const totalJobs = CITY_RESOURCES.jobs;
            const totalTalents = CITY_RESOURCES.talents;
            const totalInvestment = CITY_RESOURCES.investmentCapital;
            
            const wealthPercentage = (borough.wealthShare / totalWealth * 100).toFixed(1);
            const jobsPercentage = (borough.jobsAllocated / totalJobs * 100).toFixed(1);
            const talentsPercentage = (borough.talentsAllocated / totalTalents * 100).toFixed(1);
            const investmentPercentage = (borough.investmentAllocated / totalInvestment * 100).toFixed(1);
            
            alert(`
                Borough: ${borough.name} (${borough.status})
                
                Economic Value: ${borough.economicValue.toFixed(1)}
                Population: ${borough.population.toFixed(0)}
                Wealth Index: ${borough.wealth.toFixed(1)}
                Employment Rate: ${(borough.employmentRate * 100).toFixed(1)}%
                Business Count: ${borough.businessCount}
                Transport Connections: ${borough.transportConnections.length}
                
                Resource Allocation:
                - Wealth: ${borough.wealthShare.toFixed(0)} (${wealthPercentage}% of city)
                - Jobs: ${borough.jobsAllocated} (${jobsPercentage}% of city)
                - Talent: ${borough.talentsAllocated} (${talentsPercentage}% of city)
                - Investment: ${borough.investmentAllocated.toFixed(0)} (${investmentPercentage}% of city)
                
                Opportunity Index: ${borough.opportunity.toFixed(1)}
                Gentrification Pressure: ${(borough.gentrification * 10).toFixed(1)}
            `);
        }
        
        // Event listeners
        regenerateBtn.addEventListener('click', () => {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
            
            init();
        });
        
        runSimBtn.addEventListener('click', () => {
            if (!simulationInterval) {
                simulationInterval = setInterval(runSimulationStep, 100);
            }
        });
        
        pauseSimBtn.addEventListener('click', () => {
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = null;
            }
        });
        
        speedSlider.addEventListener('input', (e) => {
            simulationSpeed = parseInt(e.target.value);
            speedValue.textContent = `${simulationSpeed}x`;
            
            if (simulationInterval) {
                clearInterval(simulationInterval);
                simulationInterval = setInterval(runSimulationStep, 100);
            }
        });
        
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                
                currentView = e.target.dataset.view;
                renderCity();
            });
        });
        
        // Show tooltip on hover
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / GRID_SIZE);
            const y = Math.floor((e.clientY - rect.top) / GRID_SIZE);
            
            if (x >= 0 && x < COLS && y >= 0 && y < ROWS) {
                const cell = city[y][x];
                const borough = boroughs[cell.borough];
                
                let cellTypeName = "Empty";
                for (const type in CELL_TYPES) {
                    if (CELL_TYPES[type] === cell.type) {
                        cellTypeName = type.charAt(0) + type.slice(1).toLowerCase();
                        break;
                    }
                }
                
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 10) + 'px';
                tooltip.style.top = (e.clientY + 10) + 'px';
                tooltip.innerHTML = `
                    <strong>Borough:</strong> ${borough.name}<br>
                    <strong>Type:</strong> ${cellTypeName}<br>
                    <strong>Economic Value:</strong> ${cell.economicValue.toFixed(1)}<br>
                    <strong>Population:</strong> ${cell.population.toFixed(1)}<br>
                    <strong>Infrastructure:</strong> ${cell.infrastructure.toFixed(1)}<br>
                    <strong>Transport:</strong> ${cell.transport.toFixed(1)}
                `;
            } else {
                tooltip.style.display = 'none';
            }
        });
        
        canvas.addEventListener('mouseout', () => {
            tooltip.style.display = 'none';
        });
        
        // Utility functions
        function getRandomColor() {
            const r = Math.floor(Math.random() * 200) + 55;
            const g = Math.floor(Math.random() * 200) + 55;
            const b = Math.floor(Math.random() * 200) + 55;
            return rgbToHex(r, g, b);
        }
        
        function rgbToHex(r, g, b) {
            return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Initialize the simulation
        init();
    </script>
</body>
</html>